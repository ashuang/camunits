<chapter id="ch-subclassing">
    <title>Creating Custom Units -- Subclassing <classname>CamUnit</classname> and <classname>CamUnitDriver</classname></title>

    <para>
        Productively using libcam in an image processing application does not
        require one to build custom units.  It is perfectly possible, and
        sometimes simpler to simply connect a signal handler to the
        "frame-ready" signal of a <classname>CamUnitChain</classname> or
        <classname>CamUnit</classname> and do all of the processing in that
        signal handler.  So why bother creating custom units?
    </para>
    <para>
        Building a custom unit provides three main features.  
        <variablelist>
            <varlistentry>
                <term><emphasis>Controls</emphasis></term>
                <listitem>
                    <para>
                        In our experience, most image processing 
                        and image acquisition methods have some set of
                        controls and parameters that can be adjusted to affect
                        the output images. These parameters could be window
                        sizes, thresholds, scale factors, etc.  Playing with
                        hard-coded constants is often slow and tedious.
                        Using a GUI toolkit to implement widgets that control
                        the parameters is useful, but involves highly
                        repetetive code and is often tedious.
                    </para>
                    <para>
                        The <classname>CamUnit</classname> base class provides
                        a control API that allows subclasses to easily add
                        controls and parameters.  These controls can be
                        accessed and modified programmatically just as easily
                        as hard-coded parameters.  Additionally,
                        when a <classname>CamUnit</classname> is used with
                        the libcam GTK widgets (e.g.
                        <classname>CamUnitControlWidget</classname> and
                        <classname>CamUnitChain</classname>), 
                        GUI elements are automatically created that allow
                        users to adjust the exposed controls in real-time.
                    </para>
                    <para>
                        In short, <classname>CamUnit</classname> 
                        simplifies the process of exposing controls for an
                        image processing element.  These controls are
                        accessible programmatically for applications without a
                        GUI, and they are also accessible in GUI form for
                        applications that use the libcam GTK widgets.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><emphasis>Visualization via OpenGL</emphasis></term>
                <listitem>
                    <para>
                        When developing an image processing application, a
                        common and very useful debugging technique is to
                        visualize the intermediate or final stages of an
                        algorithm by rendering into the input image.  For
                        example, a face detector might circle the detected
                        faces, an optical flow algorithm might draw flow
                        vectors, etc.  libcam provides a framework for
                        integrating visualization routines into an image
                        processing element.  Subclasses of
                        <classname>CamUnit</classname> can override virtual
                        methods that will be automatically invoked when the
                        application uses a
                        <classname>CamUnitChainGLWidget</classname>.  This
                        widget takes care of setting up an OpenGL context, and
                        instructs each unit in a chain to render whatever
                        visualization it deems useful.  
                    </para>
                    <para>
                        We have specifically
                        chosen OpenGL because it is a widely used, stable
                        API that is both easy to use and has been implemented
                        on all major platforms.  Although OpenGL is typically
                        used in the context of 3D applications, it does
                        provide a highly developed and mature API for 2D
                        rendering.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><emphasis>Portability</emphasis></term>
                <listitem>
                    <para>
                        This last bit almost need not be mentioned, but I'll
                        say it for emphasis.  By conforming to the
                        <classname>CamUnit</classname> abstraction, which
                        consists primarily of an object that is capable of
                        producing or processing images, an image processing
                        element becomes much more portable.  This is
                        especially true for image processing elements that
                        transform their input into another image, such as
                        colorspace conversion units, convolution filters,
                        radial undistortion, etc.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </para>

    <sect1 id="subclassing-gobject-type-system">
        <title>The GObject Type System</title>

        <para>
            libcam is written in C, which was not designed specifically for
            object-oriented programming techniques.  The GObject type system,
            included with GLib, is essentially an object-oriented programming
            framework designed in C.  It makes heavy use of C structs and
            function pointers, provides run-time type-safety, virtual methods,
            interfaces, single-inheritance, and most of the features one would
            normally expect from an object-oriented framework.
        </para>
        <para>
            While GObject is robust and mature, it can also be very awkward to
            use in C.  We'll be completely honest here -- boilerplate code and
            nested macros abound in GObject.  It does have a learning curve,
            and it can be easy to become mired in the implementation details,
            but once you've made it past the few dozen lines of boilerplate
            needed to implement an object, everything else is pretty
            straightforward.  For more information, see the <ulink
                url="http://library.gnome.org/devel/gobject/">GObject
                Reference Manual</ulink>.  There are also several tutorials on
            GObject that can be found with some straightforward web searching.
        </para>
        <para>
            This tutorial will not focus on trying to explain how GObject
            works.  For the most part, when we have to deal with the GObject
            type system in this tutorial, we'll say something like, "just do
            it this way" and expect that if you really want to know why,
            you'll go look at the GObject documentation.
        </para>
    </sect1>
    <sect1 id="subclassing-class-relationships">
        <title>The Relationship Between Libcam Classes</title>
        <para>

            <variablelist>
                <varlistentry>
                    <term>CamUnit</term>
                    <listitem><para>
                            As mentioned earlier,
                            <classname>CamUnit</classname> is the fundamental
                            class in libcam and represents an object that can
                            produce images.  A <classname>CamUnit</classname>
                            typically produces images by processing input
                            images it receives from another
                            <classname>CamUnit</classname> (e.g. contrast
                            normalization, radial undistortion, etc.)
                            or by reading data
                            from disk or an image capture device (e.g. camera
                            or TV tuner).
                        </para>
                        <para>
                            <classname>CamUnit</classname> is an abstract base
                            class and is only useful when subclassed.
                            However, a <classname>CamUnit</classname> should
                            almost never be directly instantiated by a libcam
                            application.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>CamUnitDriver</term>
                    <listitem><para>
                            A <classname>CamUnitDriver</classname> is a
                            factory-like class responsible for enumerating the
                            availability of a <classname>CamUnit</classname>
                            and instantiating a <classname>CamUnit</classname>
                            when requested.  This feature is used primarily by
                            input units, where many or no units of a
                            particular type might be available.  For example,
                            a unit driver for Video4Linux devices would
                            enumerate all V4L devices on the system and then
                            be able to instantiate a
                            <classname>CamUnit</classname> for each V4L device
                            available.  On the other hand, drivers
                            corresponding to image processing elements will
                            typically offer one unit.
                            </para><para>
                        <classname>CamUnitDriver</classname> is also an
                        abstract base class that is only useful when
                        subclassed.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>CamUnitManager</term>
                    <listitem><para>
                            The <classname>CamUnitManager</classname> is a
                            factory class that maintains a central registry of
                            <classname>CamUnitDriver</classname>s and
                            available <classname>CamUnit</classname>s.  The
                            sole purpose of the
                            <classname>CamUnitManager</classname> is to make
                            it easy to discover available units and
                            instantiate them.
                            </para><para>
                            The relationship between
                            <classname>CamUnitManager</classname>,
                            <classname>CamUnitDriver</classname>, and
                            <classname>CamUnit</classname> is illustrated in
                            <xref
                                linkend="subclassing-relationships-manager"/>
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>CamUnitChain</term>
                    <listitem><para>
                            The <classname>CamUnitChain</classname> class
                            exists because a highly typical usage scenario is
                            to create a number of
                            <classname>CamUnit</classname> objects and then
                            connect them in sequence to form an image
                            processing chain.  A
                            <classname>CamUnitChain</classname> provides a
                            wrapper around
                            <classname>CamUnitManager</classname> and handles
                            a lot of the tedium of connecting units together.

                            </para><para>
                            The relationship between
                            <classname>CamUnitChain</classname> and the other
                            classes is illustrated in <xref
                                linkend="subclassing-relationships-chain"/>
                    </para></listitem>
                </varlistentry>
            </variablelist>
        </para>
        <figure id="subclassing-relationships-manager">
            <title>Unit, Driver, and Manager</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="images/cam_unit_manager.png" format="PNG"/>
                </imageobject>
                <caption>
                    <para>
                        A <classname>CamUnitManager</classname> contains a
                        registry of <classname>CamUnitDriver</classname>
                        objects, which are capable of instantiating
                        <classname>CamUnit</classname> objects.
                    </para>
                </caption>
            </mediaobject>
        </figure>
        <figure id="subclassing-relationships-chain">
            <title>Chain and other classes</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="images/cam_unit_chain.png" format="PNG"/>
                </imageobject>
                <caption>
                    <para>
                        A <classname>CamUnitChain</classname> wraps around a
                        <classname>CamUnitManager</classname> and does much of
                        the tedious work involved in creating and connecting
                        sequences of <classname>CamUnit</classname> objects.
                    </para>
                </caption>
            </mediaobject>
        </figure>
        <sect2 id="acquiring-relationships-connecting">
            <title><classname>CamUnit</classname> Trees</title>
            <para>
                It is possible to form image processing trees, where the
                output of one <classname>CamUnit</classname> is passed to 
                multiple <classname>CamUnit</classname> objects.  This is not
                yet well documented, however.  If
                you want to do this, best to ask on the mailing lists.
                </para><para>
                <emphasis>TODO</emphasis>  
            </para>
        </sect2>

    </sect1>
    <sect1 id="subclassing-example-filter">
        <title>Example Filter</title>
        <para>
            This example demonstrates how to create an image processing unit --
            one that takes images as input, transforms the image in some way,
            and then produces a modified image as output.  The output of this
            example unit is the original input image with a rectangle drawn in
            the middle.  A parameter allows us to control the brightness of the
            rectangle drawn.  We will call our unit "Filter Example"
        </para>
        <para>
            <xref linkend="filter_example.h"/> and <xref
                linkend="filter_example.c"/> contain the fully implemented
            unit.  This example is also distributed with the libcam.  A step
            by step explanation of the example follows.
        </para>
<example id="filter_example.h">
    <title><filename>filter_example.h</filename></title>
<programlisting>
<![CDATA[
#ifndef __my_filter_example_h__
#define __my_filter_example_h__

#include <glib-object.h>

#include <libcam/unit.h>

G_BEGIN_DECLS

// This file demonstrates how to create a simple CamUnit subclass.  When
// implementing a custom MyUnit, replace "FilterExample", "FILTER_EXAMPLE",
// and "filter_example" with your own names.  You'll also want to pick a
// different namespace (i.e. prefix) from "My"

typedef struct _MyFilterExample MyFilterExample;
typedef struct _MyFilterExampleClass MyFilterExampleClass;

// boilerplate.
#define MY_TYPE_FILTER_EXAMPLE  my_filter_example_get_type()
#define MY_FILTER_EXAMPLE(obj)  (G_TYPE_CHECK_INSTANCE_CAST( (obj), \
        MY_TYPE_FILTER_EXAMPLE, MyFilterExample))
#define MY_FILTER_EXAMPLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), \
            MY_TYPE_FILTER_EXAMPLE, MyFilterExampleClass ))
#define IS_MY_FILTER_EXAMPLE(obj)   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
            MY_TYPE_FILTER_EXAMPLE ))
#define IS_MY_FILTER_EXAMPLE_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE( \
            (klass), MY_TYPE_FILTER_EXAMPLE))
#define MY_FILTER_EXAMPLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS((obj), \
            MY_TYPE_FILTER_EXAMPLE, MyFilterExampleClass))

// object definition struct.  member variables go in here
struct _MyFilterExample {
    // the first member must always be the superclass struct
    CamUnit parent;

    // add one member variable
    CamUnitControl *patch_intensity_control;
};

// class definition.  This is pretty much a vtable, and you will rarely need to
// change it
struct _MyFilterExampleClass {
    CamUnitClass parent_class;
};

GType my_filter_example_get_type (void);

/** 
 * Constructor.
 * 
 * Don't call this function manually.  Instead, use the unit driver
 */
MyFilterExample * my_filter_example_new();

CamUnitDriver * my_filter_example_driver_new (void);

G_END_DECLS

#endif
]]>
</programlisting>
</example>
<example id="filter_example.c">
    <title><filename>filter_example.c</filename></title>
<programlisting>
<![CDATA[
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <libcam/cam.h>

#include "filter_example.h"

/* Boilerplate */
G_DEFINE_TYPE (MyFilterExample, my_filter_example, CAM_TYPE_UNIT);

CamUnitDriver *
my_filter_example_driver_new()
{
    return cam_unit_driver_new_stock ("filter", "example",
            "Example", 0, (CamUnitConstructor)my_filter_example_new);
}

// ============== MyFilterExample ===============
static void my_filter_example_finalize (GObject *obj);
static void on_input_frame_ready (CamUnit * super, const CamFrameBuffer *inbuf,
        const CamUnitFormat *infmt);
static void on_input_format_changed (CamUnit *super, 
        const CamUnitFormat *infmt);

// Class initializer
static void
my_filter_example_class_init (MyFilterExampleClass *klass)
{
    // override the destructor
    G_OBJECT_CLASS (klass)->finalize = my_filter_example_finalize;

    // override the "on_input_frame_ready" method
    klass->parent_class.on_input_frame_ready = on_input_frame_ready;
}

// First part of the constructor
MyFilterExample * 
my_filter_example_new()
{
    return MY_FILTER_EXAMPLE (g_object_new(MY_TYPE_FILTER_EXAMPLE, NULL));
}

// Initializer.  This is the second part of the constructor.
static void
my_filter_example_init (MyFilterExample *self)
{
    // Initialize the unit with some reasonable defaults here.
    CamUnit *super = CAM_UNIT (self);

    // create a control
    self->patch_intensity_control = cam_unit_add_control_int (super, 
            "patch-intensity", "Patch Intensity", 0, 255, 1, 127, 1);

    // request notification when the input of the unit changes
    g_signal_connect (G_OBJECT(self), "input-format-changed",
            G_CALLBACK(on_input_format_changed), NULL);
}

// destructor.
static void
my_filter_example_finalize (GObject *obj)
{
    // If we allocated memory on the heap/freestore, we'd release it here

    // invoke the superclass destructor
    G_OBJECT_CLASS (my_filter_example_parent_class)->finalize(obj);
}

// this method is called whenever the input unit produces a frame
static void
on_input_frame_ready (CamUnit *super, const CamFrameBuffer *inbuf, 
        const CamUnitFormat *infmt)
{
    MyFilterExample *self = MY_FILTER_EXAMPLE(super);

    CamFrameBuffer *outbuf = 
        cam_framebuffer_new_alloc (super->fmt->max_data_size);

    cam_pixel_copy_8u_generic (inbuf->data, infmt->row_stride,
            outbuf->data, super->fmt->row_stride,
            0, 0, 0, 0, infmt->width, infmt->height, 
            cam_pixel_format_bpp (infmt->pixelformat));

    // draw a little rectangle
    int x0 = super->fmt->width / 4;
    int x1 = x0 * 3;
    int rw = x1 - x0;
    int y0 = super->fmt->height / 4;
    int y1 = y0 * 3;

    int val = cam_unit_control_get_int (self->patch_intensity_control);

    int i;
    for (i=y0; i<y1; i++) {
        memset (outbuf->data + i*super->fmt->row_stride + x0*3, val, rw*3);
    }

    // copy the timestamp and metadata dictionary
    cam_framebuffer_copy_metadata (outbuf, inbuf);

    outbuf->bytesused = super->fmt->row_stride * super->fmt->height;

    cam_unit_produce_frame (super, outbuf, super->fmt);
    g_object_unref (outbuf);
}

// this is the signal handler attached in "my_filter_example_init", and is
// called when the format of the input data changes.
static void
on_input_format_changed (CamUnit *super, const CamUnitFormat *infmt)
{
    // first, clear all available output formats from this unit
    cam_unit_remove_all_output_formats (super);

    // If there is no input, then we can't produce output.  
    if (!infmt) return;
   
    // actually, we can only handle 8-bit RGB input data.
    if (infmt->pixelformat != CAM_PIXEL_FORMAT_RGB) return;

    cam_unit_add_output_format_full (super, infmt->pixelformat,
            infmt->name, infmt->width, infmt->height, 
            infmt->row_stride, infmt->max_data_size);
}
]]>
</programlisting>
</example>
        <sect2 id="subclassing-example-naming">
            <title>Naming Conventions</title>
            <para>
                Before jumping into the code, let's note a few things about
                naming conventions.  In addition to putting an object-oriented
                programming framework into C via a careful usage of structs,
                macros, and function pointers, we are also retrofitting C with
                a namespacing scheme.  Although C does not inherently support
                namespaces, we can achieve some of the benefits of a properly
                namespaced language by following careful naming rules.  libcam
                follows the GLib namespacing conventions and recommends
                the same for other applications that use libcam.
            </para>
            <para>
                The first step in adhering to these namespacing guidelines is
                to choose a namespace.  GLib chose "g", GTK chose "gtk", and
                libcam chose "cam".  The example filter uses the namespace
                "my".  The rules for naming functions, macros, and structs
                with this namespace are then:
                <itemizedlist>
                    <listitem>
                        <para><emphasis>functions and methods</emphasis> are
                            always lowercase, with words separated by
                            underscores.  e.g.
                            <literal>my_sample_function</literal>
                        </para>
                    </listitem>
                    <listitem>
                        <para><emphasis>types</emphasis> (i.e. classes,
                            structs, and enums) are almost always CamelCaps,
                            with no spaces separating words.  e.g.  
                            <literal>MySampleClass</literal>
                    </para></listitem>
                    <listitem>
                        <para><emphasis>macros</emphasis> are always
                            uppercase, with words separated by underscores.
                            e.g. <literal>MY_SAMPLE_MACRO</literal>
                    </para></listitem>
                </itemizedlist>
            </para>
        </sect2>
        <sect2 id="subclassing-example-hfile">
            <title>Filter Example <filename>.h</filename> file</title>

            <para>
                Now we'll do a line by line explanation of the header file.
            
<programlisting>
<![CDATA[
#ifndef __my_filter_example_h__
#define __my_filter_example_h__

#include <glib-object.h>
#include <libcam/unit.h>

G_BEGIN_DECLS
]]>
</programlisting>
            
                This is all required boilerplate, most of which should be
                straightforward to a C programmer.
                <literal>G_BEGIN_DECLS</literal> is a macro that provides C++
                compatibility<footnote><para>This expands to '<literal>extern
                            "C" {</literal>' in C++, to prevent C++ from
                        mangling declared function names</para></footnote>.
                The end of the file will also have a corresponding
                <literal>G_END_DECLS</literal>.

<programlisting>
<![CDATA[
typedef struct _MyFilterExample MyFilterExample;
typedef struct _MyFilterExampleClass MyFilterExampleClass;
]]>
</programlisting>

                Here, we forward-declare two structs.
                <classname>MyFilterExample</classname> will be the class
                definition struct.  This struct is what most C++ programmers
                would think of when they're defining the contents of a class.
                <classname>MyFilterExampleClass</classname> will be the class
                vtable<footnote><para><ulink
                            url="http://en.wikipedia.org/wiki/Virtual_table">http://en.wikipedia.org/wiki/Virtual_table</ulink></para></footnote>.
                
<programlisting>
<![CDATA[
// boilerplate.
#define MY_TYPE_FILTER_EXAMPLE  my_filter_example_get_type()
#define MY_FILTER_EXAMPLE(obj)  (G_TYPE_CHECK_INSTANCE_CAST( (obj), \
        MY_TYPE_FILTER_EXAMPLE, MyFilterExample))
#define MY_FILTER_EXAMPLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), \
            MY_TYPE_FILTER_EXAMPLE, MyFilterExampleClass ))
#define IS_MY_FILTER_EXAMPLE(obj)   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
            MY_TYPE_FILTER_EXAMPLE ))
#define IS_MY_FILTER_EXAMPLE_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE( \
            (klass), MY_TYPE_FILTER_EXAMPLE))
#define MY_FILTER_EXAMPLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS((obj), \
            MY_TYPE_FILTER_EXAMPLE, MyFilterExampleClass))
]]>
</programlisting>

                This constitutes the nastiest part of our boilerplate.  This
                is all GObject macro magic that will eventually make it easier
                to do runtime type checking.  For now, just do a search and
                replace, swapping out the namespace and class names
                accordingly.

<programlisting>
<![CDATA[
struct _MyFilterExample {
    // the first member must always be the superclass struct
    CamUnit parent;

    // add one member variable
    CamUnitControl *patch_intensity_control;
};

struct _MyFilterExampleClass {
    CamUnitClass parent_class;
};
]]>
</programlisting>

                These two struct definitions correspond to the class
                definition and vtable, mentioned above.  The first struct,
                <literal>struct _MyFilterExample</literal>, is what most C++
                programmers would think of in a class definition.  The first
                member of this struct <emphasis>must</emphasis> be
                <literal>CamUnit parent;</literal>.  After that, feel free to
                declare any member variables needed in the custom unit.
            </para>
            <para>
                The next struct primarily defines the virtual methods for the
                class.  Unless your class will itself be a superclass and
                provide virtual methods not defined in libcam, just rename the
                struct and leave it alone.

<programlisting>
<![CDATA[
GType my_filter_example_get_type (void);

MyFilterExample * my_filter_example_new();

CamUnitDriver * my_filter_example_driver_new (void);

G_END_DECLS

#endif
]]>
</programlisting>

                The last part of header file consists of method definitions.
                Every GObject type always has a type retrieval method, named
                <literal>xx_yy_zz_get_type</literal>.  In this case, it's
                named <literal>my_filter_example_get_type</literal>.  Rename
                that accordingly.
            </para>
            <para>
                Next, our example unit defines two constructors.  One is the
                constructor for the actual unit, the second is the constructor
                for the unit driver.  Finally, we close the header with the
                GLib macro for C++ portability, and close the original
                <literal>#ifdef</literal> at the top of the file.
            </para>
        </sect2>
        <sect2 id="subclassing-example-cfile">
            <title>Filter Example <filename>.c</filename> file</title>

            <para>
                Now we'll do a line by line explanation of the
                <filename>.c</filename> file.
            </para>

            <para>
                TODO
            </para>
<programlisting>
<![CDATA[
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <libcam/cam.h>

#include "filter_example.h"

/* Boilerplate */
G_DEFINE_TYPE (MyFilterExample, my_filter_example, CAM_TYPE_UNIT);

CamUnitDriver *
my_filter_example_driver_new()
{
    return cam_unit_driver_new_stock ("filter", "example",
            "Example", 0, (CamUnitConstructor)my_filter_example_new);
}

// ============== MyFilterExample ===============
static void my_filter_example_finalize (GObject *obj);
static void on_input_frame_ready (CamUnit * super, const CamFrameBuffer *inbuf,
        const CamUnitFormat *infmt);
static void on_input_format_changed (CamUnit *super, 
        const CamUnitFormat *infmt);

// Class initializer
static void
my_filter_example_class_init (MyFilterExampleClass *klass)
{
    // override the destructor
    G_OBJECT_CLASS (klass)->finalize = my_filter_example_finalize;

    // override the "on_input_frame_ready" method
    klass->parent_class.on_input_frame_ready = on_input_frame_ready;
}

// First part of the constructor
MyFilterExample * 
my_filter_example_new()
{
    return MY_FILTER_EXAMPLE (g_object_new(MY_TYPE_FILTER_EXAMPLE, NULL));
}

// Initializer.  This is the second part of the constructor.
static void
my_filter_example_init (MyFilterExample *self)
{
    // Initialize the unit with some reasonable defaults here.
    CamUnit *super = CAM_UNIT (self);

    // create a control
    self->patch_intensity_control = cam_unit_add_control_int (super, 
            "patch-intensity", "Patch Intensity", 0, 255, 1, 127, 1);

    // request notification when the input of the unit changes
    g_signal_connect (G_OBJECT(self), "input-format-changed",
            G_CALLBACK(on_input_format_changed), NULL);
}

// destructor.
static void
my_filter_example_finalize (GObject *obj)
{
    // If we allocated memory on the heap/freestore, we'd release it here

    // invoke the superclass destructor
    G_OBJECT_CLASS (my_filter_example_parent_class)->finalize(obj);
}

// this method is called whenever the input unit produces a frame
static void
on_input_frame_ready (CamUnit *super, const CamFrameBuffer *inbuf, 
        const CamUnitFormat *infmt)
{
    MyFilterExample *self = MY_FILTER_EXAMPLE(super);

    CamFrameBuffer *outbuf = 
        cam_framebuffer_new_alloc (super->fmt->max_data_size);

    cam_pixel_copy_8u_generic (inbuf->data, infmt->row_stride,
            outbuf->data, super->fmt->row_stride,
            0, 0, 0, 0, infmt->width, infmt->height, 
            cam_pixel_format_bpp (infmt->pixelformat));

    // draw a little rectangle
    int x0 = super->fmt->width / 4;
    int x1 = x0 * 3;
    int rw = x1 - x0;
    int y0 = super->fmt->height / 4;
    int y1 = y0 * 3;

    int val = cam_unit_control_get_int (self->patch_intensity_control);

    int i;
    for (i=y0; i<y1; i++) {
        memset (outbuf->data + i*super->fmt->row_stride + x0*3, val, rw*3);
    }

    // copy the timestamp and metadata dictionary
    cam_framebuffer_copy_metadata (outbuf, inbuf);

    outbuf->bytesused = super->fmt->row_stride * super->fmt->height;

    cam_unit_produce_frame (super, outbuf, super->fmt);
    g_object_unref (outbuf);
}

// this is the signal handler attached in "my_filter_example_init", and is
// called when the format of the input data changes.
static void
on_input_format_changed (CamUnit *super, const CamUnitFormat *infmt)
{
    // first, clear all available output formats from this unit
    cam_unit_remove_all_output_formats (super);

    // If there is no input, then we can't produce output.  
    if (!infmt) return;
   
    // actually, we can only handle 8-bit RGB input data.
    if (infmt->pixelformat != CAM_PIXEL_FORMAT_RGB) return;

    cam_unit_add_output_format_full (super, infmt->pixelformat,
            infmt->name, infmt->width, infmt->height, 
            infmt->row_stride, infmt->max_data_size);
}
]]>
</programlisting>
        
        </sect2>
    </sect1>
</chapter>
