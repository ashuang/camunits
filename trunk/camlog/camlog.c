#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <getopt.h>
#include <unistd.h>

#include <glib.h>

#include <libcam/cam.h>

#include "signal_pipe.h"

typedef struct _state_t {
    int verbose;
    int frameno;
    int64_t lasttime;
} state_t;

#define FRAMES_PER_PRINTF   100

static int64_t _timestamp_now()
{
    struct timeval tv;
    gettimeofday (&tv, NULL);
    return (int64_t) tv.tv_sec * 1000000 + tv.tv_usec;
}

static void
on_frame_ready (CamUnitChain *chain, CamUnit *unit, const CamFrameBuffer *buf, 
        void *user_data)
{
    state_t *self = user_data;

    if (self->verbose) {
        printf("frame: %d\n", self->frameno);
    }
    if (self->frameno % FRAMES_PER_PRINTF == 0) {
        int64_t timestamp;
        timestamp = _timestamp_now ();
        if (self->lasttime != 0) {
            printf ("%d frames at %.1f Hz\n", self->frameno,
                    FRAMES_PER_PRINTF * 1000000.0 /
                    (timestamp - self->lasttime));
        }
        self->lasttime = timestamp;
    }
    self->frameno++;
}

static void
print_inputs (CamUnitManager *manager)
{
    fprintf(stderr, "Available inputs:\n\n"); 
    GList *udlist = cam_unit_manager_list_package (manager, "input", TRUE);
    for (GList *uditer=udlist; uditer; uditer=uditer->next) {
        CamUnitDescription *udesc = CAM_UNIT_DESCRIPTION(uditer->data);
        printf("  %s  (%s)\n", udesc->unit_id, udesc->name);
    }
    g_list_free(udlist);
}

static void
usage (const char *progname)
{
    fprintf(stderr, 
        "Usage: %s [OPTIONS] -i <input_id> [output_file]\n"
        "\n"
        "Writes full resolution raw video data to disk.\n"
        "Filename for video data is autogenerated if not specified\n"
        "\n"
        "Options:\n"
        " -h      Shows this help text\n"
        " -f      Force overwrite of output_file if it already exists\n"
        " -n      Do not write video data to disk.\n\n",
        progname);
}

int main(int argc, char **argv)
{
    int status = 1;

    const char *logfname = NULL;
    char *input_id = NULL;
    int overwrite = 0;
    int interval = -1;
    int do_logging = 1;
    GMainLoop *mainloop = NULL;
    state_t *self = (state_t*)calloc(1, sizeof(state_t));
    self->verbose = 0;
    self->frameno = 0;

    setlinebuf (stdout);
    setlinebuf (stderr);

    char *optstring = "hi:fvp:l:ntb:s:j";
    char c;
    struct option long_opts[] = { 
        { "help", no_argument, 0, 'h' },
        { "input", required_argument, 0, 'i' },
        { "force", no_argument, 0, 'f' },
        { "verbose", no_argument, 0, 'v' },
        { "no-write", no_argument, 0, 'n' },
        { 0, 0, 0, 0 }
    };

    g_type_init();

    while ((c = getopt_long (argc, argv, optstring, long_opts, 0)) >= 0)
    {
        switch (c) {
            case 'i':
                input_id = strdup(optarg);
                break;
            case 'f':
                overwrite = 1;
                break;
            case 'v':
                self->verbose = 1;
                break;
            case 'p':
                interval = atoi (optarg);
                break;
            case 'n':
                do_logging = 0;
                break;
            case 'h':
            default:
                usage (argv[0]);
                return 1;
        };
    }

    // setup the image processing chain
    CamUnitChain * chain = cam_unit_chain_new();

    sleep (1);

    if (!input_id) {
        usage(argv[0]); 
        print_inputs(chain->manager);
        goto done;
    }
    if (optind == argc-1) {
        logfname = argv[optind];
        // don't overwrite files unless -f was specified
        if (!overwrite && g_file_test(logfname, G_FILE_TEST_EXISTS)) {
            fprintf(stderr, "output file exists and -f not specified.\n");
            fprintf(stderr, "file: %s\n", logfname);
            goto done;
        }
    }

    // create the GLib mainloop
    mainloop = g_main_loop_new (NULL, FALSE);
    signal_pipe_glib_quit_on_kill (mainloop);

    // instantiate the input unit
    CamUnit *input = cam_unit_chain_add_unit_by_id(chain, input_id);
    if (! input) {
        fprintf(stderr, "CRAP!  Couldn't create input unit [%s].\n\n", 
                input_id);
        print_inputs(chain->manager);
        goto done;
    }

    cam_unit_stream_init_any_format (input);

    CamUnitControl * record_ctl;
    CamUnit *logger_unit = NULL;
    if (do_logging) {
        fprintf (stderr, "initializing logging unit\n");
        // create the logger unit and add it to the chain.
        logger_unit = cam_unit_chain_add_unit_by_id(chain, 
                "output.logger");
        assert(logger_unit);

        // set the filename, and start the logger unit recording
        if (logfname) {
            cam_unit_set_control_string (logger_unit, "filename", logfname);
        }
        cam_unit_set_control_boolean (logger_unit, "record", TRUE);
    } else {
        fprintf (stderr, "not logging to disk\n");
    }

    // start the chain streaming
    cam_unit_chain_set_desired_status (chain, CAM_UNIT_STATUS_STREAMING);

    // did everything start up correctly?
    CamUnit *faulty_unit = cam_unit_chain_check_status_all_units (chain, 
                CAM_UNIT_STATUS_STREAMING);
    if (faulty_unit) {
        fprintf (stderr, "Unit [%s] is not streaming, aborting...\n",
                cam_unit_get_name (faulty_unit));
        goto done;
    }

    cam_unit_chain_attach_glib (chain, 1000, NULL);
    g_signal_connect (G_OBJECT (chain), "frame-ready",
            G_CALLBACK (on_frame_ready), self);
    printf ("verbose: %d\n", self->verbose);

    // run the main loop
    g_main_loop_run (mainloop);

    // stop recording
    if (logfname && logger_unit)
        cam_unit_set_control_boolean (logger_unit, "record", FALSE);

    // cleanup
    status = 0;
done:
    if (mainloop) g_main_loop_unref (mainloop);
    if (chain) {
        cam_unit_chain_set_desired_status (chain, CAM_UNIT_STATUS_IDLE);
        g_object_unref (chain);
    }
    if (input_id) free(input_id);
    if (self) {
        free (self);
    }
    return status;
}
