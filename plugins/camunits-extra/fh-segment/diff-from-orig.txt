Only in .: diff-from-orig.txt
diff -u ../segment-orig/disjoint-set.h ./disjoint-set.h
--- ../segment-orig/disjoint-set.h	2006-12-28 13:10:20.000000000 -0500
+++ ./disjoint-set.h	2008-06-11 18:07:32.000000000 -0400
@@ -21,59 +21,60 @@
 
 // disjoint-set forests using union-by-rank and path compression (sort of).
 
-typedef struct {
-  int rank;
-  int p;
-  int size;
-} uni_elt;
-
-class universe {
-public:
-  universe(int elements);
-  ~universe();
-  int find(int x);  
-  void join(int x, int y);
-  int size(int x) const { return elts[x].size; }
-  int num_sets() const { return num; }
-
-private:
-  uni_elt *elts;
-  int num;
+class disjoint_set_forest {
+    public:
+        class element {
+            public:
+                int rank;
+                int p;
+                int size;
+        };
+
+        disjoint_set_forest(int elements);
+        ~disjoint_set_forest();
+        int find(int x);  
+        void join(int x, int y);
+        int size(int x) const { return elts[x].size; }
+        int num_sets() const { return num; }
+
+    private:
+        element *elts;
+        int num;
 };
 
-universe::universe(int elements) {
-  elts = new uni_elt[elements];
-  num = elements;
-  for (int i = 0; i < elements; i++) {
-    elts[i].rank = 0;
-    elts[i].size = 1;
-    elts[i].p = i;
-  }
-}
-  
-universe::~universe() {
-  delete [] elts;
+disjoint_set_forest::disjoint_set_forest(int elements) {
+    elts = new element[elements];
+    num = elements;
+    for (int i = 0; i < elements; i++) {
+        elts[i].rank = 0;
+        elts[i].size = 1;
+        elts[i].p = i;
+    }
 }
 
-int universe::find(int x) {
-  int y = x;
-  while (y != elts[y].p)
-    y = elts[y].p;
-  elts[x].p = y;
-  return y;
+disjoint_set_forest::~disjoint_set_forest() {
+    delete [] elts;
 }
 
-void universe::join(int x, int y) {
-  if (elts[x].rank > elts[y].rank) {
-    elts[y].p = x;
-    elts[x].size += elts[y].size;
-  } else {
+int disjoint_set_forest::find(int x) {
+    int y = x;
+    while (y != elts[y].p)
+        y = elts[y].p;
     elts[x].p = y;
-    elts[y].size += elts[x].size;
-    if (elts[x].rank == elts[y].rank)
-      elts[y].rank++;
-  }
-  num--;
+    return y;
+}
+
+void disjoint_set_forest::join(int x, int y) {
+    if (elts[x].rank > elts[y].rank) {
+        elts[y].p = x;
+        elts[x].size += elts[y].size;
+    } else {
+        elts[x].p = y;
+        elts[y].size += elts[x].size;
+        if (elts[x].rank == elts[y].rank)
+            elts[y].rank++;
+    }
+    num--;
 }
 
 #endif
diff -u ../segment-orig/filter.h ./filter.h
--- ../segment-orig/filter.h	2006-12-28 13:10:18.000000000 -0500
+++ ./filter.h	2008-06-11 18:05:17.000000000 -0400
@@ -79,22 +79,4 @@
   return dst;
 }
 
-/* compute laplacian */
-static image<float> *laplacian(image<float> *src) {
-  int width = src->width();
-  int height = src->height();
-  image<float> *dst = new image<float>(width, height);  
-
-  for (int y = 1; y < height-1; y++) {
-    for (int x = 1; x < width-1; x++) {
-      float d2x = imRef(src, x-1, y) + imRef(src, x+1, y) -
-	2*imRef(src, x, y);
-      float d2y = imRef(src, x, y-1) + imRef(src, x, y+1) -
-	2*imRef(src, x, y);
-      imRef(dst, x, y) = d2x + d2y;
-    }
-  }
-  return dst;
-}
-
 #endif
diff -u ../segment-orig/segment-graph.h ./segment-graph.h
--- ../segment-orig/segment-graph.h	2006-12-28 13:10:06.000000000 -0500
+++ ./segment-graph.h	2008-06-11 18:05:19.000000000 -0400
@@ -45,13 +45,13 @@
  * edges: array of edges.
  * c: constant for treshold function.
  */
-universe *segment_graph(int num_vertices, int num_edges, edge *edges, 
+disjoint_set_forest *segment_graph(int num_vertices, int num_edges, edge *edges, 
 			float c) { 
   // sort edges by weight
   std::sort(edges, edges + num_edges);
 
   // make a disjoint-set forest
-  universe *u = new universe(num_vertices);
+  disjoint_set_forest *u = new disjoint_set_forest(num_vertices);
 
   // init thresholds
   float *threshold = new float[num_vertices];
diff -u ../segment-orig/segment-image.h ./segment-image.h
--- ../segment-orig/segment-image.h	2007-03-21 16:59:31.000000000 -0400
+++ ./segment-image.h	2008-06-11 18:07:22.000000000 -0400
@@ -20,29 +20,17 @@
 #define SEGMENT_IMAGE
 
 #include <cstdlib>
-#include <image.h>
-#include <misc.h>
-#include <filter.h>
+#include "image.h"
+#include "misc.h"
+#include "filter.h"
 #include "segment-graph.h"
 
-// random color
-rgb random_rgb(){ 
-  rgb c;
-  double r;
-  
-  c.r = (uchar)random();
-  c.g = (uchar)random();
-  c.b = (uchar)random();
-
-  return c;
-}
-
 // dissimilarity measure between pixels
 static inline float diff(image<float> *r, image<float> *g, image<float> *b,
-			 int x1, int y1, int x2, int y2) {
-  return sqrt(square(imRef(r, x1, y1)-imRef(r, x2, y2)) +
-	      square(imRef(g, x1, y1)-imRef(g, x2, y2)) +
-	      square(imRef(b, x1, y1)-imRef(b, x2, y2)));
+        int x1, int y1, int x2, int y2) {
+    return sqrt(square(imRef(r, x1, y1)-imRef(r, x2, y2)) +
+            square(imRef(g, x1, y1)-imRef(g, x2, y2)) +
+            square(imRef(b, x1, y1)-imRef(b, x2, y2)));
 }
 
 /*
@@ -54,101 +42,86 @@
  * sigma: to smooth the image.
  * c: constant for treshold function.
  * min_size: minimum component size (enforced by post-processing stage).
- * num_ccs: number of connected components in the segmentation.
  */
-image<rgb> *segment_image(image<rgb> *im, float sigma, float c, int min_size,
-			  int *num_ccs) {
-  int width = im->width();
-  int height = im->height();
-
-  image<float> *r = new image<float>(width, height);
-  image<float> *g = new image<float>(width, height);
-  image<float> *b = new image<float>(width, height);
-
-  // smooth each color channel  
-  for (int y = 0; y < height; y++) {
-    for (int x = 0; x < width; x++) {
-      imRef(r, x, y) = imRef(im, x, y).r;
-      imRef(g, x, y) = imRef(im, x, y).g;
-      imRef(b, x, y) = imRef(im, x, y).b;
+disjoint_set_forest *segment_image(image<rgb> *im, float sigma, float c, int min_size) {
+    int width = im->width();
+    int height = im->height();
+
+    image<float> *r = new image<float>(width, height);
+    image<float> *g = new image<float>(width, height);
+    image<float> *b = new image<float>(width, height);
+
+    // smooth each color channel  
+    for (int y = 0; y < height; y++) {
+        for (int x = 0; x < width; x++) {
+            imRef(r, x, y) = imRef(im, x, y).r;
+            imRef(g, x, y) = imRef(im, x, y).g;
+            imRef(b, x, y) = imRef(im, x, y).b;
+        }
     }
-  }
-  image<float> *smooth_r = smooth(r, sigma);
-  image<float> *smooth_g = smooth(g, sigma);
-  image<float> *smooth_b = smooth(b, sigma);
-  delete r;
-  delete g;
-  delete b;
- 
-  // build graph
-  edge *edges = new edge[width*height*4];
-  int num = 0;
-  for (int y = 0; y < height; y++) {
-    for (int x = 0; x < width; x++) {
-      if (x < width-1) {
-	edges[num].a = y * width + x;
-	edges[num].b = y * width + (x+1);
-	edges[num].w = diff(smooth_r, smooth_g, smooth_b, x, y, x+1, y);
-	num++;
-      }
-
-      if (y < height-1) {
-	edges[num].a = y * width + x;
-	edges[num].b = (y+1) * width + x;
-	edges[num].w = diff(smooth_r, smooth_g, smooth_b, x, y, x, y+1);
-	num++;
-      }
-
-      if ((x < width-1) && (y < height-1)) {
-	edges[num].a = y * width + x;
-	edges[num].b = (y+1) * width + (x+1);
-	edges[num].w = diff(smooth_r, smooth_g, smooth_b, x, y, x+1, y+1);
-	num++;
-      }
-
-      if ((x < width-1) && (y > 0)) {
-	edges[num].a = y * width + x;
-	edges[num].b = (y-1) * width + (x+1);
-	edges[num].w = diff(smooth_r, smooth_g, smooth_b, x, y, x+1, y-1);
-	num++;
-      }
+    image<float> *smooth_r = smooth(r, sigma);
+    image<float> *smooth_g = smooth(g, sigma);
+    image<float> *smooth_b = smooth(b, sigma);
+    delete r;
+    delete g;
+    delete b;
+
+    // build graph
+    edge *edges = new edge[width*height*4];
+    int num = 0;
+    for (int y = 0; y < height; y++) {
+        for (int x = 0; x < width; x++) {
+            if (x < width-1) {
+                edges[num].a = y * width + x;
+                edges[num].b = y * width + (x+1);
+                edges[num].w = 
+                    diff(smooth_r, smooth_g, smooth_b, x, y, x+1, y);
+                num++;
+            }
+
+            if (y < height-1) {
+                edges[num].a = y * width + x;
+                edges[num].b = (y+1) * width + x;
+                edges[num].w = 
+                    diff(smooth_r, smooth_g, smooth_b, x, y, x, y+1);
+                num++;
+            }
+
+            if ((x < width-1) && (y < height-1)) {
+                edges[num].a = y * width + x;
+                edges[num].b = (y+1) * width + (x+1);
+                edges[num].w = 
+                    diff(smooth_r, smooth_g, smooth_b, x, y, x+1, y+1);
+                num++;
+            }
+
+            if ((x < width-1) && (y > 0)) {
+                edges[num].a = y * width + x;
+                edges[num].b = (y-1) * width + (x+1);
+                edges[num].w = 
+                    diff(smooth_r, smooth_g, smooth_b, x, y, x+1, y-1);
+                num++;
+            }
+        }
     }
-  }
-  delete smooth_r;
-  delete smooth_g;
-  delete smooth_b;
-
-  // segment
-  universe *u = segment_graph(width*height, num, edges, c);
-  
-  // post process small components
-  for (int i = 0; i < num; i++) {
-    int a = u->find(edges[i].a);
-    int b = u->find(edges[i].b);
-    if ((a != b) && ((u->size(a) < min_size) || (u->size(b) < min_size)))
-      u->join(a, b);
-  }
-  delete [] edges;
-  *num_ccs = u->num_sets();
-
-  image<rgb> *output = new image<rgb>(width, height);
-
-  // pick random colors for each component
-  rgb *colors = new rgb[width*height];
-  for (int i = 0; i < width*height; i++)
-    colors[i] = random_rgb();
-  
-  for (int y = 0; y < height; y++) {
-    for (int x = 0; x < width; x++) {
-      int comp = u->find(y * width + x);
-      imRef(output, x, y) = colors[comp];
+
+    // segment
+    disjoint_set_forest *u = segment_graph(width*height, num, edges, c);
+
+    // post process small components
+    for (int i = 0; i < num; i++) {
+        int a = u->find(edges[i].a);
+        int b = u->find(edges[i].b);
+        if ((a != b) && ((u->size(a) < min_size) || (u->size(b) < min_size)))
+            u->join(a, b);
     }
-  }  
+    delete [] edges;
 
-  delete [] colors;  
-  delete u;
+    delete smooth_r;
+    delete smooth_g;
+    delete smooth_b;
 
-  return output;
+    return u ;
 }
 
 #endif
